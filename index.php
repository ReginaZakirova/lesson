<?php

//  Задание 12 - 4, 5

/*  По сути задание сводится к тому, что нам необходимо сформировать два множества, элементами которых являются
    отдельные предложения. А потом над этими двумя исходными множествами произвести операции логического объединения
    и пересечения.
    Первая задача, которую необходимо решить - это формирование самого исходного множества предложений из файла.
    Так как файлов два, будем разумно решить данную задачу посредством функции, которая принимает файл, а возвращает
    массив предложений строкового типа. */

function file_to_sentence($file_name) {
    $file = file_get_contents($file_name);    // Считать содержимое первого файла как строку в $file.
    /*  Для формирования отдельных монолитных строк предложений необходимо ликвидировать символы новой
    строки "\n\r" - и для этого я решил воспользоваться функцией str_replace(). Будем ее использовать в два этапа:
    1. Замена сочетания "\r\n" на символ одиночного пробела.
    2. Замена двух последовательных пробелов одиночным пробелом.
    Такие действия позволят корректно склеить предложение, в случае, если оно было расположено в исходном файле
    посредством переноса с одной строки на другую. */
    $file = str_replace("\r\n", " ", $file);
    $file = str_replace("  ", " ", $file);
    /*  На данном этапе содержимое файла представлено в соответствующей переменной строкового типа. Теперь
    нам необходимо разбить эту единую строку на отдельные предложения с учетом условия, обговоренного в конце занятия,
    что предложение у нас заканчивается одним из следующих символов: . ! ?
    Не могу придумать ничего более лучшего, чем разбить исходную строку на массив символов и собирать искомые строки
    посимвольно. */
    $array_file = mb_str_split($file);  // Преобразуем строку в массив символов.
    $sentence_array = [];               // Здесь будем хранить массив отдельных предложений.
    $len = count($array_file);          // Длина исходного масива символов
    $sentence = null;                   // Новое отдельное предложение
    for ($i = 0; $i <= $len; $i++) {
        $sentence = $sentence . $array_file[$i];    // Генерируем предложение конкатенацией посимвольно.
        if (($array_file[$i] == ".") or ($array_file[$i] == "!") or ($array_file[$i] == "?")) {
            // Если достигли конца предложения, помещаем его в массив.
            $sentence_array[] = $sentence;
            $i++;                                   // Игнорируем пробел перед следующим предложением.
            $sentence = null;                       // Сбрасываем текущее предложение.
        }
    }
    return $sentence_array;
}

echo "Задание 12 - 4, 5<br><br>";
echo "Содержимое первого файла как массив предложений: <br>";
echo "<pre>";
$arr1 = file_to_sentence('file1.txt'); // Получаем массив предложений из первого файла.
print_r($arr1);
echo "</pre>";
echo "Содержимое второго файла как массив предложений: <br>";
echo "<pre>";
$arr2 = file_to_sentence('file2.txt'); // Получаем массив предложений из первого файла.
print_r($arr2);
echo "</pre><br>";

$fp1 = fopen('file3.txt', 'w+');    // Файл с предложениями входящими в оба массива хотя бы раз.
$fp2 = fopen('file4.txt', 'w+');    // Файл с предложениями общими для двух массивов.
/*  Сразу запишем все содержимое первого массива в третий файл! Для чего я это сделал?! Проще всего это
    объяснить рассмотрев решение задачи, как диаграммы Венна на двух множествах! (Я вложил рисунок в текущий репо
    с логикой действий.) Это эквивалентно созданию множества, включающие все элементы первого множества,
    как уникальные для него, так и общие с элементами второго множества (если таковые есть!) за вычетом элементов
    уникальных для второго множества! В дальнейшем я добавлю сюда элементы уникальные для второго множества и
    тем самым решу задачу 4. */
foreach ($arr1 as $item1) {
    fwrite($fp1, ($item1 . "\r\n"));
}
/*  А теперь будем сразу решать и задачу 4 и задачу 5 в одном цикле благодаря такой интересной конструкции
    как оператор continue c количеством вложений. Я придумал это ночью в начале шестого часа утра - как же
    это красиво! */

/*  Будем пробегать каждое предложение из второго файла в сравнении c каждым предложением из первого файла.
    Если совпадение есть, то выводим общее предложение сразу в четвертый файл и принудительно переходим
    на следующую итерацию цикла во втором вложении! А если нет - то мы просто пробежим весь внутренний цикл,
    и из этого будет следовать что совпадений не было и мы пишем текущее предложение из второго файла в третий файл! */
foreach ($arr2 as $item2) {
    foreach ($arr1 as $item1) {
        if ($item2 == $item1) {
            fwrite($fp2, ($item2 . "\r\n"));
            continue 2;
        }
    }
    fwrite($fp1, ($item2 . "\r\n"));
}
fclose($fp1);
fclose($fp2);

echo "Содержимое сгенерированного третьего файла: <br>";
echo "<pre>";
print_r(file_get_contents('file3.txt'));
echo "</pre><br>";
echo "Содержимое сгенерированного четвертого файла: <br>";
echo "<pre>";
print_r(file_get_contents('file4.txt'));
echo "</pre><br>";

